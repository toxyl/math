// Code generated by go:generate; DO NOT EDIT.

package math

import "math"

// Core functions: wrappers for functions in the standard math package.

// Abs wraps math.Abs in a generic function..

func Abs[N Number](x N) N {
	return N(math.Abs(float64(x)))
}


// Acosh wraps math.Acosh in a generic function..

func Acosh[N Number](x N) N {
	return N(math.Acosh(float64(x)))
}


// Asin wraps math.Asin in a generic function..

func Asin[N Number](x N) N {
	return N(math.Asin(float64(x)))
}


// Acos wraps math.Acos in a generic function..

func Acos[N Number](x N) N {
	return N(math.Acos(float64(x)))
}


// Asinh wraps math.Asinh in a generic function..

func Asinh[N Number](x N) N {
	return N(math.Asinh(float64(x)))
}


// Atan wraps math.Atan in a generic function..

func Atan[N Number](x N) N {
	return N(math.Atan(float64(x)))
}


// Atan2 wraps math.Atan2 in a generic function..

func Atan2[N Number](y, x N) N {
	return N(math.Atan2(float64(y), float64(x)))
}


// Atanh wraps math.Atanh in a generic function..

func Atanh[N Number](x N) N {
	return N(math.Atanh(float64(x)))
}


// Inf is a direct alias to math.Inf.

// Direct alias.
var Inf = math.Inf


// NaN wraps math.NaN in a generic function..

func NaN[N Number]() N {
	return N(math.NaN())
}


// IsNaN is a direct alias to math.IsNaN.

// Direct alias.
var IsNaN = math.IsNaN


// IsInf is a direct alias to math.IsInf.

// Direct alias.
var IsInf = math.IsInf


// Cbrt wraps math.Cbrt in a generic function..

func Cbrt[N Number](x N) N {
	return N(math.Cbrt(float64(x)))
}


// Copysign wraps math.Copysign in a generic function..

func Copysign[N Number](f, sign N) N {
	return N(math.Copysign(float64(f), float64(sign)))
}


// Dim wraps math.Dim in a generic function..

func Dim[N Number](x, y N) N {
	return N(math.Dim(float64(x), float64(y)))
}


// Max wraps math.Max in a generic function..

func Max[N Number](x, y N) N {
	return N(math.Max(float64(x), float64(y)))
}


// Min wraps math.Min in a generic function..

func Min[N Number](x, y N) N {
	return N(math.Min(float64(x), float64(y)))
}


// Erf wraps math.Erf in a generic function..

func Erf[N Number](x N) N {
	return N(math.Erf(float64(x)))
}


// Erfc wraps math.Erfc in a generic function..

func Erfc[N Number](x N) N {
	return N(math.Erfc(float64(x)))
}


// Erfinv wraps math.Erfinv in a generic function..

func Erfinv[N Number](x N) N {
	return N(math.Erfinv(float64(x)))
}


// Erfcinv wraps math.Erfcinv in a generic function..

func Erfcinv[N Number](x N) N {
	return N(math.Erfcinv(float64(x)))
}


// Exp wraps math.Exp in a generic function..

func Exp[N Number](x N) N {
	return N(math.Exp(float64(x)))
}


// Exp2 wraps math.Exp2 in a generic function..

func Exp2[N Number](x N) N {
	return N(math.Exp2(float64(x)))
}


// Expm1 wraps math.Expm1 in a generic function..

func Expm1[N Number](x N) N {
	return N(math.Expm1(float64(x)))
}


// Floor wraps math.Floor in a generic function..

func Floor[N Number](x N) N {
	return N(math.Floor(float64(x)))
}


// Ceil wraps math.Ceil in a generic function..

func Ceil[N Number](x N) N {
	return N(math.Ceil(float64(x)))
}


// Trunc wraps math.Trunc in a generic function..

func Trunc[N Number](x N) N {
	return N(math.Trunc(float64(x)))
}


// Round wraps math.Round in a generic function..

func Round[N Number](x N) N {
	return N(math.Round(float64(x)))
}


// RoundToEven wraps math.RoundToEven in a generic function..

func RoundToEven[N Number](x N) N {
	return N(math.RoundToEven(float64(x)))
}


// FMA wraps math.FMA in a generic function..

func FMA[N Number](x, y, z N) N {
	return N(math.FMA(float64(x), float64(y), float64(z)))
}


// Frexp is a direct alias to math.Frexp.

// Direct alias.
var Frexp = math.Frexp


// Gamma wraps math.Gamma in a generic function..

func Gamma[N Number](x N) N {
	return N(math.Gamma(float64(x)))
}


// Hypot wraps math.Hypot in a generic function..

func Hypot[N Number](p, q N) N {
	return N(math.Hypot(float64(p), float64(q)))
}


// J0 wraps math.J0 in a generic function..

func J0[N Number](x N) N {
	return N(math.J0(float64(x)))
}


// Y0 wraps math.Y0 in a generic function..

func Y0[N Number](x N) N {
	return N(math.Y0(float64(x)))
}


// J1 wraps math.J1 in a generic function..

func J1[N Number](x N) N {
	return N(math.J1(float64(x)))
}


// Y1 wraps math.Y1 in a generic function..

func Y1[N Number](x N) N {
	return N(math.Y1(float64(x)))
}


// Jn is a direct alias to math.Jn.

// Direct alias.
var Jn = math.Jn


// Yn is a direct alias to math.Yn.

// Direct alias.
var Yn = math.Yn


// Ldexp is a direct alias to math.Ldexp.

// Direct alias.
var Ldexp = math.Ldexp


// Lgamma is a direct alias to math.Lgamma.

// Direct alias.
var Lgamma = math.Lgamma


// Log wraps math.Log in a generic function..

func Log[N Number](x N) N {
	return N(math.Log(float64(x)))
}


// Log10 wraps math.Log10 in a generic function..

func Log10[N Number](x N) N {
	return N(math.Log10(float64(x)))
}


// Log2 wraps math.Log2 in a generic function..

func Log2[N Number](x N) N {
	return N(math.Log2(float64(x)))
}


// Log1p wraps math.Log1p in a generic function..

func Log1p[N Number](x N) N {
	return N(math.Log1p(float64(x)))
}


// Logb wraps math.Logb in a generic function..

func Logb[N Number](x N) N {
	return N(math.Logb(float64(x)))
}


// Ilogb is a direct alias to math.Ilogb.

// Direct alias.
var Ilogb = math.Ilogb


// Mod wraps math.Mod in a generic function..

func Mod[N Number](x, y N) N {
	return N(math.Mod(float64(x), float64(y)))
}


// Modf is a direct alias to math.Modf.

// Direct alias.
var Modf = math.Modf


// Nextafter32 is a direct alias to math.Nextafter32.

// Direct alias.
var Nextafter32 = math.Nextafter32


// Nextafter wraps math.Nextafter in a generic function..

func Nextafter[N Number](x, y N) N {
	return N(math.Nextafter(float64(x), float64(y)))
}


// Pow wraps math.Pow in a generic function..

func Pow[N Number](x, y N) N {
	return N(math.Pow(float64(x), float64(y)))
}


// Pow10 is a direct alias to math.Pow10.

// Direct alias.
var Pow10 = math.Pow10


// Remainder wraps math.Remainder in a generic function..

func Remainder[N Number](x, y N) N {
	return N(math.Remainder(float64(x), float64(y)))
}


// Signbit is a direct alias to math.Signbit.

// Direct alias.
var Signbit = math.Signbit


// Cos wraps math.Cos in a generic function..

func Cos[N Number](x N) N {
	return N(math.Cos(float64(x)))
}


// Sin wraps math.Sin in a generic function..

func Sin[N Number](x N) N {
	return N(math.Sin(float64(x)))
}


// Sincos is a direct alias to math.Sincos.

// Direct alias.
var Sincos = math.Sincos


// Sinh wraps math.Sinh in a generic function..

func Sinh[N Number](x N) N {
	return N(math.Sinh(float64(x)))
}


// Cosh wraps math.Cosh in a generic function..

func Cosh[N Number](x N) N {
	return N(math.Cosh(float64(x)))
}


// Sqrt wraps math.Sqrt in a generic function..

func Sqrt[N Number](x N) N {
	return N(math.Sqrt(float64(x)))
}


// Tan wraps math.Tan in a generic function..

func Tan[N Number](x N) N {
	return N(math.Tan(float64(x)))
}


// Tanh wraps math.Tanh in a generic function..

func Tanh[N Number](x N) N {
	return N(math.Tanh(float64(x)))
}


// Float32bits is a direct alias to math.Float32bits.

// Direct alias.
var Float32bits = math.Float32bits


// Float32frombits is a direct alias to math.Float32frombits.

// Direct alias.
var Float32frombits = math.Float32frombits


// Float64bits is a direct alias to math.Float64bits.

// Direct alias.
var Float64bits = math.Float64bits


// Float64frombits is a direct alias to math.Float64frombits.

// Direct alias.
var Float64frombits = math.Float64frombits


